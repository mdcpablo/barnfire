#! /usr/bin/env python

#MINE
from directories import get_common_directories

#STDLIB
import os
import sys
import copy
sys.path.insert(1, get_common_directories()['nuclideData'])

#TPL
import time
import numpy as np
import matplotlib as mpl
import matplotlib.pyplot as plt
import nuclide_data as nd

#MINE
from makegroups import write_egrid
import materials_materials as mat
from materials_util import calc_chord_length, get_nuclide_dirr

mpl.rcParams.update({'font.size': 16, 'lines.linewidth': 2})

def define_defaults():
    '''Specify default parameters'''
    # Main parameters (plotOutput is always by default False)
    verbosity = True
    resolution = 9
    min_rel_diff = 1e-8
    energySpacing = 1.5
    #workOpt = 'sigt'
    #workOpt = 'wgt'
    #workOpt = 'flux'
    workOpt = 'fluxe'

    # Specify range of interest (for output fluxes and plotting)
    #rrrRange = [6E-1, 1.06E3]
    #rrrRange = [3.0, 55.6]
    ##rrrRange = [55.6, 1.06E3]
    ####rrrRange = [3.0E0, 1.06E3]
    #rrrRange = [3.0, 2.5E4]
    rrrRange = [1E-5,2E7]

    # Specify which coarse group structure to use outside the RRR
    groupOpt = 'scale-44'

    # Specify constants for the fast Maxwellian shape
    #WattConstants = [0.88111, 3.4005] #thermal fission from U-238
    #WattConstants = [0.966, 2.842] # thermal fission from Pu-239
    WattConstants = [0.988, 2.2249] #thermal fission from U-235

    # Specify which set of materials to use
    #materialOpt = '3'
    #materialOpt = '4'
    ##materialOpt = '5'
    #materialOpt = 'c5g7'
    #materialOpt = 'graphite'
    #materialOpt = 'iron'
    materialOpt = 'manual'

    # If materialOpt is 'manual', list of materials to use
    materialsList = ['deb']

    # Specify energy mesh for output weights / fluxes
    #meshName = 'clust-{r}'
    meshName = 'res-{r}'

    return {'verbosity': verbosity, 'workopt': workOpt, 'resolution':resolution, 'min_rel_diff':min_rel_diff, 'energyspacing': energySpacing, 'rrr': rrrRange,'groupopt': groupOpt, 'materialopt': materialOpt, 'meshname': meshName, 'fastspectrumparam': WattConstants, 'listmaterials': materialsList}



def do_all(inputDict):
    '''Create Sigma_t for the specified materials on a proper grid for later clustering'''
    # Read in options
    verbosity = inputDict['verbosity']
    workOpt = inputDict['workopt']
    materialOpt = inputDict['materialopt']
    pwResFactor = inputDict['resolution']
    rrrRange = inputDict['rrr']
    meshName = inputDict['meshname']
    numElements = inputDict['numElements']
    numSpeedGroups = inputDict['numSpeedGroups']
    coarseBdrs = inputDict['coarsebdrs']
    apportionOpt = inputDict['apportionopt']

    # Specify materials
    materials = []
    if materialOpt == '3':
        materials.append(mat.get_inner_hot_mox_material())
        materials.append(mat.get_middle_hot_mox_material())
        materials.append(mat.get_outer_hot_mox_material())
        # O in UO2 does not have a temperature at 550 K, so the PENDF lookup fails
        #if workOpt == 'wgt':
        #    materials.append(mat.get_hot_h2o_material())
        temperatureDependence = True
    elif materialOpt in ['HEU_MET_FAST_001','4','5']:
        materials.append(mat.get_cold_mox_material())
        materials.append(mat.get_cold_uo2_material())
        if workOpt == 'wgt':
            materials.append(mat.get_cold_h2o_material())
        if materialOpt == '5':
            chordLength = calc_chord_length("cylinder", 0.597)
            materials[1].update_chord_length(chordLength)
        # Materials generated by python script
    elif materialOpt == 'HEU_MET_FAST_001':
        importanceDict = {'Godiva': 1} 
    elif materialOpt == 'Pure_U235_and_Natural_Iron':
        materials.append(mat.get_Natural_Iron_material())
        if workOpt == 'wgt':
            materials.append(mat.get_Pure_U235_material())
    elif materialOpt == 'Pu239_and_Air':
        materials.append(mat.get_Pu239_material())
        if workOpt == 'wgt':
            materials.append(mat.get_Air_material())
    elif materialOpt == 'Natural_Iron':
        materials.append(mat.get_Natural_Iron_material())
    elif materialOpt == 'Iron_and_U235':
        materials.append(mat.get_Pure_U235_material())
        if workOpt == 'wgt':
            materials.append(mat.get_Natural_Iron_material())
    elif materialOpt == 'Pure_U235':
        materials.append(mat.get_Pure_U235_material())
    elif materialOpt == 'HEU':
        materials.append(mat.get_HEU_material())    
        # -----------------------------------
    elif materialOpt == 'graphite':
        materials.append(mat.get_graphite_material())
    elif materialOpt == 'iron':
        materials.append(mat.get_iron_material())
        if workOpt == 'wgt':
            materials.append(mat.get_pu_metal_material())
            materials.append(mat.get_thick_iron_material())
    elif materialOpt == 'c5g7':
        materials.append(mat.get_c5g7_uo2_material())
        materials.append(mat.get_c5g7_high_mox_material())
        if workOpt == 'wgt':
            materials.append(mat.get_c5g7_low_mox_material())
            materials.append(mat.get_c5g7_med_mox_material())
            materials.append(mat.get_c5g7_control_rod_material())
            materials.append(mat.get_c5g7_fission_chamber_material())
            materials.append(mat.get_c5g7_guide_tube_material())
            materials.append(mat.get_c5g7_moderator_material())
    elif materialOpt == 'kpin':
        materials.append(mat.get_kord_fuel_material())
        if workOpt == 'wgt':
            materials.append(mat.get_kord_enriched_fuel_material())
            materials.append(mat.get_kord_zirconium_material())
            materials.append(mat.get_kord_moderator_material())
            materials.append(mat.get_kord_rod_fuel_material())
    elif materialOpt == 'kenrichedpin':
        materials.append(mat.get_kord_fuel_material())
        materials.append(mat.get_kord_enriched_fuel_material())
        if workOpt == 'wgt':
            materials.append(mat.get_kord_zirconium_material())
            materials.append(mat.get_kord_moderator_material())
            materials.append(mat.get_kord_rod_fuel_material())
    elif materialOpt == 'kpin2d':
        materials.append(mat.get_kord_rod_fuel_material())
        if workOpt == 'wgt':
            materials.append(mat.get_kord_fuel_material())
            materials.append(mat.get_kord_moderator_material())
            materials.append(mat.get_kord_enriched_rod_fuel_material())
            materials.append(mat.get_kord_mox_rod_fuel_material())
    elif materialOpt == 'kenrichedpin2d':
        materials.append(mat.get_kord_rod_fuel_material())
        materials.append(mat.get_kord_enriched_rod_fuel_material())
        if workOpt == 'wgt':
            materials.append(mat.get_kord_fuel_material())
            materials.append(mat.get_kord_moderator_material())
            materials.append(mat.get_kord_mox_rod_fuel_material())
    elif materialOpt == 'kmoxpin2d':
        materials.append(mat.get_kord_rod_fuel_material())
        materials.append(mat.get_kord_mox_rod_fuel_material())
        if workOpt == 'wgt':
            materials.append(mat.get_kord_fuel_material())
            materials.append(mat.get_kord_moderator_material())
            materials.append(mat.get_kord_enriched_rod_fuel_material())
    elif materialOpt == 'kmoxenrichedpin2d':
        materials.append(mat.get_kord_rod_fuel_material())
        materials.append(mat.get_kord_enriched_rod_fuel_material())
        materials.append(mat.get_kord_mox_rod_fuel_material())
        if workOpt == 'wgt':
            materials.append(mat.get_kord_fuel_material())
            materials.append(mat.get_kord_moderator_material())
    elif materialOpt == 'kcladpin':
        materials.append(mat.get_kord_fuel_material())
        materials.append(mat.get_kord_enriched_fuel_material())
        materials.append(mat.get_kord_zirconium_material())
        if workOpt == 'wgt':
            materials.append(mat.get_kord_moderator_material())
            materials.append(mat.get_kord_rod_fuel_material())
    elif materialOpt == 'CASL':
        materials.append(mat.get_CASL_fuel_p4_211_material())
        materials.append(mat.get_CASL_fuel_p4_262_material())
        materials.append(mat.get_CASL_fuel_p5_31_material())
        if workOpt == 'wgt':
            materials.append(mat.get_CASL_cladding_p5_material())
            materials.append(mat.get_CASL_pyrex_p5_material())
            materials.append(mat.get_CASL_AIC_p5_material())
            materials.append(mat.get_CASL_B4C_p5_material())
            materials.append(mat.get_CASL_moderator_p5_material())
            materials.append(mat.get_CASL_gas_p5_material())
            materials.append(mat.get_CASL_coreplates_material())
            materials.append(mat.get_CASL_StainlessSteel_p5_material())
    elif materialOpt == 'deb':
        materials.append(mat.get_bruss_enriched_rod_fuel_material())
    else:
        #materialOpt == 'manual'
        materialFunctionDict = mat.get_materials_name2function_dict()
        for materialName in materialsList:
            materials.append(materialFunctionDict[materialName]())

    save_material_speeds(materials, meshName, pwResFactor, coarseBdrs, apportionOpt, numElements, numSpeedGroups)
    
###############################################################################
def get_sub_energies(clust):
    sub_ehigh = clust[:-1,1]
    sub_emid = np.zeros(len(clust)-1)
    sub_de = np.zeros(len(clust)-1)
    for i in range(len(clust)-1):
        sub_emid[i] = (clust[i,1] + clust[i+1,1])/2.
        sub_de[i] = clust[i,1] - clust[i+1,1]
    return sub_ehigh, sub_emid, sub_de 

def get_sub_velocities(sub_emid):
    return 2.9979e10*np.sqrt(2e-6*sub_emid/939.57)

def get_mapping_sub_to_elem(clust):
    return clust[:-1,0].astype(dtype=int)

def get_reverse_mapping_for_array(mapping_array):
    mapping_list_of_lists = []
    for i in range(int(max(mapping_array))+1):
        mapping_list_of_lists.append([])
    for i in range(len(mapping_array)):
        mapping_list_of_lists[mapping_array[i]].append(i)
    return mapping_list_of_lists

def get_new_mapping(mapping_elem_to_sg, mapping_sg_to_sub, pointer_array):
    new_mapping_sg_to_sub = []
    for sg in range(len(mapping_sg_to_sub)):
        new_mapping_sg_to_sub.append(mapping_sg_to_sub[pointer_array[sg]])
    pointer_array_matrix = np.array([np.arange(len(pointer_array),dtype=int), pointer_array]).transpose()
    pointer_array_matrix_sorted = sorted(pointer_array_matrix, key=lambda a: a[1], reverse=False)
    reverse_pointer_array = [int(pointer_array_matrix_sorted[i][0]) for i in range(len(pointer_array))]
    new_mapping_elem_to_sg = []
    for e in range(len(mapping_elem_to_sg)):
        new_mapping_elem_to_sg.append([])
        for sg in range(len(mapping_elem_to_sg[e])):
            new_mapping_elem_to_sg[e].append(reverse_pointer_array[mapping_elem_to_sg[e][sg]])
    return new_mapping_elem_to_sg, new_mapping_sg_to_sub


def get_sub_weights(wgt):
    return wgt[:,1]

def calc_group_total_values(sub_vals, mapping_group_to_sub):
    group_vals = np.zeros(len(mapping_group_to_sub))
    for g in range(len(mapping_group_to_sub)):
        for s in range(len(mapping_group_to_sub[g])):
            group_vals[g] += sub_vals[mapping_group_to_sub[g][s]]
    return group_vals

def calc_group_averaged_values(sub_vals, sub_wgt, group_wgt, mapping_group_to_sub):
    group_vals = np.zeros(len(mapping_group_to_sub))
    for g in range(len(mapping_group_to_sub)):
        for s in range(len(mapping_group_to_sub[g])):
            group_vals[g] += sub_vals[mapping_group_to_sub[g][s]] * (sub_wgt[mapping_group_to_sub[g][s]] / group_wgt[g])
            #print group_vals[g],sub_vals[mapping_group_to_sub[g][s]],sub_wgt[mapping_group_to_sub[g][s]],group_wgt[g]
    return group_vals 
            
def get_elem_sg_2(coarseBdrs, sub_emid, elem, n):
    '''Inserts inverse-velocity-spaced group boundaries within each coarse group'''  
    sgBdrs = []
    for i in range(len(coarseBdrs)-1):
        #E_bdrs = np.logspace(np.log10(coarseBdrs[i]),np.log10(coarseBdrs[i+1]),num=n+1)
        inv_sqrt_E_bdrs = np.logspace(np.log10(coarseBdrs[i]**(-0.5)),np.log10(coarseBdrs[i+1]**(-0.5)),num=n+1)
        for j in range(n):
            #sgBdrs.append(E_bdrs[j])
            sgBdrs.append(inv_sqrt_E_bdrs[j]**(-2))
    sgBdrs.append(coarseBdrs[-1])
    local_num_of_elem_sg = np.zeros(max(elem)+1)
    local_num_of_elem_sg[0] += 1
    elem_sg = np.zeros(len(elem), dtype=int)
    prev_elem = [0] 
    prev_elems_in_sg = [0]
    j_start = 0
    for i in range(1,len(elem)):
        if sub_emid[i] > sgBdrs[0] or sub_emid[i] < sgBdrs[-1]:
            elem_sg[i] = max(elem_sg) + 1
            local_num_of_elem_sg[elem[i]] += 1
            prev_elem.append(elem[i])
        else:
            for j in range(j_start, len(sgBdrs)-1):
                #print sgBdrs[j+1], sub_emid[i], sgBdrs[j]
                if sgBdrs[j+1] < sub_emid[i] < sgBdrs[j]:
                    if j != j_start:
                        j_start = np.copy(j)
                        prev_elems_in_sg = []
                    if elem[i] not in prev_elems_in_sg:
                        elem_sg[i] = max(elem_sg) + 1
                        local_num_of_elem_sg[elem[i]] += 1
                        prev_elem.append(elem[i])
                        prev_elems_in_sg.append(elem[i])          
                    else:
                        elem_sg[i] = max(elem_sg) - (max(prev_elem) - elem[i])
                    break  
        #print elem_sg[i], elem[i]
    print "# elements =", max(elem)+1, "\n# speed groups =", int(sum(local_num_of_elem_sg)), "\nlocal_num_of_elem_sg =",  local_num_of_elem_sg

    mapping_sg_to_elem = np.zeros(int(max(elem_sg))+1, dtype=int)

    mapping_elem_to_sub = []
    for i in range(int(max(elem))+1):
       mapping_elem_to_sub.append([])

    mapping_elem_to_sg = []
    for i in range(int(max(elem))+1):
       mapping_elem_to_sg.append([])

    mapping_sg_to_sub = []
    for i in range(int(max(elem_sg))+1):
       mapping_sg_to_sub.append([])

    for i in range(len(elem_sg)):
        mapping_sg_to_elem[elem_sg[i]] = np.copy(elem[i])

        mapping_sg_to_sub[elem_sg[i]].append(i)

        mapping_elem_to_sub[elem[i]].append(i)
        mapping_elem_to_sg[elem[i]].append(elem_sg[i])

    print mapping_elem_to_sg

    return elem_sg

def get_elem_sg_4(coarseBdrs, sub_ehigh, sub_wgt, elem_wgt, mapping_elem_to_sub, max_num_speed_groups):
    '''Inserts integrated-flux-spaced group boundaries within each coarse group'''  
    mapping_elem_to_sg = []
    for i in range(len(mapping_elem_to_sub)):
       mapping_elem_to_sg.append([])

    mapping_sg_to_sub = []
  
    elem_sum_wgts = []
    for i in range(len(mapping_elem_to_sub)):
        elem_sum_wgts.append([])

    for e in range(len(mapping_elem_to_sub)):
        for s in range(len(mapping_elem_to_sub[e])):
            if s == 0:
                elem_sum_wgts[e].append( sub_wgt[mapping_elem_to_sub[e][s]]/elem_wgt[e] )
            else:
                elem_sum_wgts[e].append( elem_sum_wgts[e][s-1] + sub_wgt[mapping_elem_to_sub[e][s]]/elem_wgt[e] )
            #print elem_sum_wgts[e][-1]

    cg_de = np.zeros(len(mapping_elem_to_sub))
    cg_dLogE = np.zeros(len(mapping_elem_to_sub))

    print "\n\n\n\n\n\n\n\n\n\n\n"
    sg = 0
    for e in range(len(mapping_elem_to_sub)): 
        if coarseBdrs[-1] < sub_ehigh[mapping_elem_to_sub[e][0]]-1e-14 < coarseBdrs[0]:
            for j in range(len(coarseBdrs)-1):
                    if coarseBdrs[j+1] < sub_ehigh[mapping_elem_to_sub[e][0]]-1e-14 < coarseBdrs[j]:
                        cg_de[e] = coarseBdrs[j] - coarseBdrs[j+1]
                        cg_dLogE[e] = np.log(coarseBdrs[j]) - np.log(coarseBdrs[j+1])

        if len(mapping_elem_to_sub[e]) > 1:
            exit = False
            print "################################################################################"
            print "| ELEMENT "+str(e)+" |"
            print " ------------"
            for n in range(max_num_speed_groups, 0, -1):
                if exit == True:
                    break
                elem_split_locations = []
                for m in range(1,n):
                    #print elem_split_locations
                    #print elem_sum_wgts[e]
                    #print np.float(m)/np.float(n)
                    distances = [np.abs(elem_sum_wgts[e][s] - np.float(m)/np.float(n)) for s in range(len(elem_sum_wgts[e]))]
                    #print distances
                    for s in range(len(elem_sum_wgts[e])):
                        if np.abs(distances[s] - min(distances)) < 1e-14:
                            if s not in elem_split_locations and s != 0:
                                elem_split_locations.append( s )
                                break
                print n, elem_split_locations                         
                ehigh = np.zeros(len(elem_sum_wgts[e]))
                elow = np.zeros(len(elem_sum_wgts[e]))
                for s in range(len(elem_sum_wgts[e])):
                    ehigh[s] = sub_ehigh[mapping_elem_to_sub[e][s]]
                    elow[s] = sub_ehigh[mapping_elem_to_sub[e][s]+1]
                improved_elem_split_locations = copy.copy(elem_split_locations)
                for i in range(len(elem_split_locations)):
                    if i == 0:
                        LogSpeedSpacing_OnLeft = (np.log(ehigh[0]) - np.log(elow[elem_split_locations[i]]))/cg_dLogE[e]
                    else:
                        LogSpeedSpacing_OnLeft = (np.log(elow[elem_split_locations[i-1]]) - np.log(elow[elem_split_locations[i]]))/cg_dLogE[e]

                    if i+1 == len(elem_split_locations):
                        LogSpeedSpacing_OnRight = (np.log(elow[elem_split_locations[i]]) - np.log(elow[-1]))/cg_dLogE[e]
                    else:
                        LogSpeedSpacing_OnRight = (np.log(elow[elem_split_locations[i]]) - np.log(elow[elem_split_locations[i+1]]))/cg_dLogE[e]

                    if LogSpeedSpacing_OnLeft > 0.5/np.float(max_num_speed_groups) and LogSpeedSpacing_OnRight > 0.5/np.float(max_num_speed_groups):
                        exit = True
                        print elem_split_locations[i], LogSpeedSpacing_OnLeft, LogSpeedSpacing_OnRight
                    else: 
                        exit = False
                        print elem_split_locations[i], LogSpeedSpacing_OnLeft, LogSpeedSpacing_OnRight, "<- left and/or right is less than", 0.5/np.float(max_num_speed_groups)
                        print "... reducing number of speed groups in element",e,"...\n"
                        break

            if len(elem_split_locations) == 0:
                mapping_sg_to_sub.append([])
                mapping_sg_to_sub[sg] = copy.copy( mapping_elem_to_sub[e] )
                if sg not in mapping_elem_to_sg[e]:
                    mapping_elem_to_sg[e].append(sg)
                sg += 1
            else:
                for i in range(len(elem_split_locations)):
                    if i == 0:
                        mapping_sg_to_sub.append([])
                        mapping_sg_to_sub[sg] = copy.copy( mapping_elem_to_sub[e][0:elem_split_locations[i]] )
                        if sg not in mapping_elem_to_sg[e]:
                            mapping_elem_to_sg[e].append(sg)
                        sg += 1
                    else:
                        mapping_sg_to_sub.append([])
                        mapping_sg_to_sub[sg] = copy.copy( mapping_elem_to_sub[e][elem_split_locations[i-1]:elem_split_locations[i]] )
                        if sg not in mapping_elem_to_sg[e]:
                            mapping_elem_to_sg[e].append(sg)
                        sg += 1
                    if i == len(elem_split_locations)-1:
                        mapping_sg_to_sub.append([])
                        mapping_sg_to_sub[sg] = copy.copy( mapping_elem_to_sub[e][elem_split_locations[i]:] )
                        if sg not in mapping_elem_to_sg[e]:
                            mapping_elem_to_sg[e].append(sg)
                        sg += 1
        else:
            mapping_sg_to_sub.append([])
            mapping_sg_to_sub[sg] = copy.copy( mapping_elem_to_sub[e] )
            if sg not in mapping_elem_to_sg[e]:
                mapping_elem_to_sg[e].append(sg)
            sg += 1

            #for s in range(len(mapping_elem_to_sub[e])):
    print "################################################################################"

    for e in range(len(mapping_elem_to_sg)):
        print len(mapping_elem_to_sg[e]), mapping_elem_to_sg[e]

    return mapping_elem_to_sg, mapping_sg_to_sub
                
###############################################################################
def save_material_speeds(materials, meshName, pwResFactor, coarseBdrs, apportionOpt, numElements, numSpeedGroups):
    '''Blah blah blah'''
    # Set the output dat directory
    datDirr = get_common_directories()['dat/indicators']
    clustDirr = get_common_directories()['dat/energy_groups']
    clust_filePath = os.path.join(clustDirr, meshName+'.txt')
    clust = np.loadtxt(clust_filePath, skiprows=2, usecols=[0,1])

    numCoarseGroups = len(coarseBdrs) - 1

    for iMat, material in enumerate(materials):
        materialName = material.shortName
        filename = 'wgt_{0}_{1}.txt'.format(materialName, pwResFactor)
        filePath = os.path.join(datDirr, filename)
        wgt = np.loadtxt(filePath, skiprows=1)

    filename = 'aptn_{0}_e{1}_g{2}.txt'.format(apportionOpt, numElements, numCoarseGroups)
    filePath = os.path.join(datDirr, filename)
    aptn = np.loadtxt(filePath, skiprows=2)

    coarseBdrs = coarseBdrs[::-1]

    sub_ehigh, sub_emid, sub_de  = get_sub_energies(clust)      
    sub_wgt                      = get_sub_weights(wgt)
    sub_v                        = get_sub_velocities(sub_emid)

    mapping_sub_to_elem          = get_mapping_sub_to_elem(clust)
    mapping_elem_to_sub          = get_reverse_mapping_for_array(mapping_sub_to_elem)
    elem_de                      = calc_group_total_values(sub_de, mapping_elem_to_sub)
    elem_wgt                     = calc_group_total_values(sub_wgt, mapping_elem_to_sub)
    elem_v                       = calc_group_averaged_values(sub_v, sub_wgt, elem_wgt, mapping_elem_to_sub)

    for max_num_speed_groups in numSpeedGroups:
        '''option = 2
        if option == 1:
            elem_sg       = get_elem_sg(coarseBdrs, sub_ehigh, elem, sub_wgt, elem_wgt, max_num_speed_groups)
        elif option == 2:
            elem_sg       = get_elem_sg_2(coarseBdrs, sub_emid, elem, max_num_speed_groups)
        '''
        #elem_sg = get_elem_sg_3(coarseBdrs, sub_ehigh, elem, sub_wgt, elem_wgt, max_num_speed_groups)
        mapping_elem_to_sg, mapping_sg_to_sub = get_elem_sg_4(coarseBdrs, sub_ehigh, sub_wgt, elem_wgt, mapping_elem_to_sub, max_num_speed_groups)

        mapping_sub_to_sg = np.zeros(len(sub_wgt),dtype=int)
        for sg in range(len(mapping_sg_to_sub)):
            for sub in range(len(mapping_sg_to_sub[sg])):
                mapping_sub_to_sg[mapping_sg_to_sub[sg][sub]] = np.copy(sg)

        elem_sg_de     = calc_group_total_values(sub_de, mapping_sg_to_sub)
        elem_sg_wgt    = calc_group_total_values(sub_wgt, mapping_sg_to_sub)
        elem_sg_v      = calc_group_averaged_values(sub_v, sub_wgt, elem_sg_wgt, mapping_sg_to_sub)

        # ------------------- Re-ordering speed groups -----------------------
        elem_sg_v_matrix = np.array([np.arange(len(elem_sg_v),dtype=int), elem_sg_v]).transpose()
        elem_sg_v_matrix_sorted = sorted(elem_sg_v_matrix, key=lambda a: a[1], reverse=True)
        pointer_array = [int(elem_sg_v_matrix_sorted[i][0]) for i in range(len(elem_sg_v))]
        mapping_elem_to_sg, mapping_sg_to_sub = get_new_mapping(mapping_elem_to_sg, mapping_sg_to_sub, pointer_array)
        elem_sg_de     = calc_group_total_values(sub_de, mapping_sg_to_sub)
        elem_sg_wgt    = calc_group_total_values(sub_wgt, mapping_sg_to_sub)
        elem_sg_v      = calc_group_averaged_values(sub_v, sub_wgt, elem_sg_wgt, mapping_sg_to_sub)
        # ---------------------------------------------------------------------

        elem_sg_emid = np.zeros(len(elem_sg_de))
        elem_sg_ehigh = np.zeros(len(elem_sg_de)+1)
        elem_sg_ehigh[0] = np.copy( sub_ehigh[0] )
        for i in range(len(elem_sg_de)):
            elem_sg_ehigh[i+1] = elem_sg_ehigh[i] - elem_sg_de[i]
            elem_sg_emid[i] = 0.5*(elem_sg_ehigh[i] + elem_sg_ehigh[i+1])
            #print 1e-6*elem_sg_emid[i], 0.5*(939.57/3e10**2)*elem_sg_v[i]**2

        if min(elem_sg_emid[:-1]-elem_sg_emid[1:]) < 0:
            print "\n\n\n\n'Energy groups' are out of order!\n\n\n\n"

        elem_sg_wgt_over_elem_wgt = np.zeros(len(elem_sg_wgt))
        for e in range(len(mapping_elem_to_sg)):
            #print e, mapping_elem_to_sg[e]
            for sg in range(len(mapping_elem_to_sg[e])):
                 #print e, mapping_elem_to_sg[e], sg, elem_sg_wgt[mapping_elem_to_sg[e][sg]], elem_wgt[e]
                 elem_sg_wgt_over_elem_wgt[mapping_elem_to_sg[e][sg]] = elem_sg_wgt[mapping_elem_to_sg[e][sg]]/elem_wgt[e]     
        print elem_sg_wgt_over_elem_wgt
        print max(elem_sg_wgt_over_elem_wgt)   

        elem_sg_subelement_array = np.zeros(len(sub_emid))
        elem_sg_emid_subelement_array = np.zeros(len(sub_emid))
        elem_sg_de_subelement_array = np.zeros(len(sub_emid))
        elem_sg_v_subelement_array = np.zeros(len(sub_emid))
        elem_sg_wgt_over_elem_wgt_subelement_array = np.zeros(len(sub_emid))
        for sg in range(len(mapping_sg_to_sub)):
            for s in range(len(mapping_sg_to_sub[sg])):
                elem_sg_subelement_array[mapping_sg_to_sub[sg][s]] = int(sg)
                elem_sg_emid_subelement_array[mapping_sg_to_sub[sg][s]] = elem_sg_emid[sg]
                elem_sg_de_subelement_array[mapping_sg_to_sub[sg][s]] = elem_sg_de[sg]
                elem_sg_v_subelement_array[mapping_sg_to_sub[sg][s]] = elem_sg_v[sg]
                elem_sg_wgt_over_elem_wgt_subelement_array[mapping_sg_to_sub[sg][s]] = elem_sg_wgt_over_elem_wgt[sg]

        speeds_filename = 'elem_sg_{0}_{1}cg_{2}el_{3}sg.txt'.format(materialName, numCoarseGroups, numElements, max_num_speed_groups)
        speeds_filePath = os.path.join(datDirr, speeds_filename)
        matrix_to_save = [mapping_sub_to_elem, sub_emid, sub_de, elem_sg_subelement_array, 1e-6*elem_sg_emid_subelement_array, 1e-6*elem_sg_de_subelement_array, elem_sg_v_subelement_array, elem_sg_wgt_over_elem_wgt_subelement_array]
        header_to_print = 'element_number,        subelement_emid,         subelement_de,       element_speed_group_number, element_speed_group_emid, element_speed_group_de, element_speed_group_speed, elem_sg_wgt_over_elem_wgt'
        np.savetxt(speeds_filePath, np.transpose(matrix_to_save), header=header_to_print)

        '''
        plt.xscale('log')
        plt.yscale('log')
        plt.xlim([1e4,1e7])
        plt.ylim([1,1e3])
        for i in range(len(sub_ehigh)-1):
            plt.fill_between([sub_ehigh[i], sub_ehigh[i+1]], 1e-13, [sub_wgt[i], sub_wgt[i]])
        plt.show()
        plt.close()
        '''
        '''
        plt.xscale('log')
        plt.xlim([2e4,1e6])
        for i in range(len(elem_sg)-1):
            plt.plot([sub_ehigh[i], sub_ehigh[i+1]], [elem[i],elem[i]], 'b', linewidth=2)
            plt.plot([sub_ehigh[i], sub_ehigh[i+1]], [elem_sg[i],elem_sg[i]], 'r', linewidth=2)
        plt.show()
        plt.close()
        '''
        '''
        plt.scatter(elem_v,np.ones(len(elem_v)),color='b',marker='|')
        plt.scatter(elem_sg_v,2.*np.ones(len(elem_sg_v)),color='r',marker='|')
        plt.xscale('log')
        plt.xlim([1e8,1e10])
        plt.ylim([0,10])
        plt.show()
        plt.close()
        '''

###############################################################################
def define_input_parser():
    import argparse
    #
    parser = argparse.ArgumentParser(description='Calculator of indicators.', formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    defaults = define_defaults()
    # If nothing is specified, verbosity is False. If -v or --verbose is specified, verbosity is 1. If -v N is specified, verbosity is N.
    parser.add_argument('-v', '--verbose', dest='verbosity', nargs='?', const=1, default=defaults['verbosity'], choices=[0,1,2,3,4], type=int)
    parser.add_argument('-a', '--apportionopt', help="Specify how to assign the number of energy elements per coarse group, if not explicitly specified using 'listnumelements'. 'equal' means use an equal number of elements per coarse group. 'var', 'max', 'birch', and 'L1' are four ways that assign elements in proportion to the relative variance within a coarse group. 'L1' is not normalized to the number of fine points per coarse group and is more useful for 'amg' and 'tmg' work options. 'birch' uses the number of Birch clusters, and is approximate.", choices=['equal', 'var', 'max', 'birch', 'L1'], default='var')
    parser.add_argument('-w', '--workopt', help='What to do. flux means calculate infinite-medium flux. fluxe means calculate infinite-medium flux with escape cross section. sigt means calculate total macroscopic cross section. flux and fluxe store psi*dE/M(E), where M(E)=1/E in the RRR. wgt means do fluxe but store the MG flux (psi*dE).', choices=['flux', 'fluxe', 'sigt', 'wgt'], default=defaults['workopt'])
    parser.add_argument('-R', '--resolvedresrange', dest='rrr', help='Energy range of resolved resonance region.', type=float, nargs=2, default=defaults['rrr'])
    parser.add_argument('-g', '--numElements', help="Number of Elements", type=int, default=1)
    parser.add_argument('-s', '--numSpeedGroups', help="Maximum number of speed groups per element", type=int, nargs='+', default=[2])
    parser.add_argument('-r', '--resolution', help='Resolution to use for the pointwise flux calculations', type=int, choices=range(11), default=defaults['resolution'])
    parser.add_argument('-m', '--materialopt', help=" Unless 'manual' is used, specifies a set of materials to use. If 'manual' is used, give a space-separated list of material names in 'listmaterials'.", choices=['HEU','Pure_U235_and_Natural_Iron','Pure_U235','Iron_and_U235','Natural_Iron','Pu239_and_Air','3','HEU_MET_FAST_001','4','5','c5g7', 'graphite', 'iron', 'kpin', 'kenrichedpin', 'kcladpin', 'kpin2d', 'kenrichedpin2d', 'kmoxpin2d', 'kmoxenrichedpin2d', 'CASL', 'deb', 'manual'], default=defaults['materialopt'])
    parser.add_argument('-M', '--meshname', help="The energy mesh on which the output fluxes are constructed. {r} is replaced by the resolution. If the 'flux' workopt is used, the mesh file is written to. Else, is it read from. If no file type is specified, '.txt' is used. If no directory is specified, the 'energyDat' directory from directories is used.", default=defaults['meshname'])
    parser.add_argument('-c', '--coarsebdrs', help='The resolved resonance range and how it is to be split into coarse groups (one clustering calculation per coarse group).', type=float, nargs='+', default=0)
    return parser

###############################################################################
if __name__ == '__main__':
    parser = define_input_parser()
    inputDict = vars(parser.parse_args())
    if inputDict['verbosity'] > 1:
        print 'Summary of inputs:'
        print inputDict
    do_all(inputDict)

