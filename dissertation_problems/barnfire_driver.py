'''
This python script was originally written for personal use, and was written to:
1) Automate the process of creating a new material, unfortunately is was done by hard coding material definitions and specifications into the Barnfire source code
2) Manually create a fixed coarse-group energy grid
3) Create bash scripts to run Barnfire, and allow the user to easily generate
    a) continuous-energy cross sections
    b) multigroup cross sections
    c) finite-element-with-discontiguous-support (FEDS) cross sections
4) Create a directory that neatly stores important Barnfire output and cross section files

BE CAREFUL, "barnfire_driver.py" may delete or add lines from the following files in the Barnfire source code:
1) indicators.py
2) indicators_clustering.py
3) materials_materials.py

PLEASE NOTE, the capablilities of Barnfire are greater than what this script offers. Feel free to:
1) add functions to "barnfire_driver.py"
1) modify the bash scripts (generated by "barnfire_driver.py") before running them
2) create materials in the Barnfire source code without deleting or overwriting existing materials

ALSO, PLEASE MODIFY THE LINE BELOW!
'''
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
barnfire_src_dir = '/home/pablo/barnfire/src' 
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
import os
import sys
sys.path.append(barnfire_src_dir)
import directories
import numpy as np
import datetime
import copy
import time

dirDict = directories.get_root_directories()
headDirr = dirDict['head']
srcDict = directories.get_source_directories(headDirr)
groupstructDirr = srcDict['common_group_structures']

dirDict = directories.get_root_directories()
scratchDirr = dirDict['scratch']
scratchDict = directories.get_scratch_directories(scratchDirr)
clustDirr = scratchDict['dat/energy_groups']

#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
def ReadFile(filename):
    # Reads a file as a 1D and 2D list 
    # The 1D list contains lines the file, the 2D list delimits each line by space
    f = open(filename)
    list_1D = []
    list_2D = []
    for line in f:
        list_1D.append(line)
        list_2D.append(line.split())
    f.close()
    return list_1D, list_2D
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
def run_barnfire_driver(prob, geom):
    ### creates a multi-group structure
    if prob.create_multigroup_structure == True:
        prob = create_group_struct(prob)
    #else:
    #    prob.group_file = 'pablo-mg-1059.txt'
    #    prob = read_group_struct(prob.group_file)

    ### creates and runs "make_xs_*.sh" file
    if prob.create_barnfire_bash_script == True:
        create_PDT_xs(prob, geom)
        if prob.run_barnfire_bash_script == True:
            os.system('bash '+prob.make_PDT_xs_file)

    if prob.create_MCNP_cross_sections == True:
        os.system('bash '+scratchDirr+'/xs/RunAce.sh')
        os.system('bash '+scratchDirr+'/xs/ace/xdata/copyAce.sh')
        os.system('tail '+scratchDirr+'/barnfire/xs/ace/xdata/xsdir')
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
def create_group_struct(prob):
    # ----- variables used in this function -------
    num_low_E_bins = prob.num_low_E_bins
    num_mid_E_bins = prob.num_mid_E_bins
    num_high_E_bins = prob.num_high_E_bins
    log_spacing = prob.log_spacing
    range_bounds = prob.range_bounds 
    # ---------------------------------------------

    if log_spacing == True:
        low_E_bins = np.logspace(np.log10(range_bounds[1]), np.log10(range_bounds[0]), num=num_low_E_bins+1)
        mid_E_bins = np.logspace(np.log10(range_bounds[2]), np.log10(range_bounds[1]), num=num_mid_E_bins+1)
        high_E_bins = np.logspace(np.log10(range_bounds[3]), np.log10(range_bounds[2]), num=num_high_E_bins+1)
        group_file = 'log-'+str(num_low_E_bins)+'-'+str(num_mid_E_bins)+'-'+str(num_high_E_bins)+'.txt'
        group_file = os.path.join(groupstructDirr, group_file)
    else:
        low_E_bins = np.logspace(range_bounds[1], range_bounds[0], num=num_low_E_bins+1)
        mid_E_bins = np.logspace(range_bounds[2], range_bounds[1], num=num_mid_E_bins+1)
        high_E_bins = np.logspace(range_bounds[3], range_bounds[2], num=num_high_E_bins+1)
        group_file = 'lin-'+str(num_low_E_bins)+'-'+str(num_mid_E_bins)+'-'+str(num_high_E_bins)+'.txt'
        group_file = os.path.join(groupstructDirr, group_file)

    f = open(group_file, 'w')
    f.write('User-generated using "barnfire_functions.py"\n')
    f.write('group upper bound region\n')
    for i in range(num_high_E_bins+1):
        f.write('%i %10.10e fast\n' %(i+1, high_E_bins[i]))
    j = 0
    if num_mid_E_bins != 0:
        for j in range(1,num_mid_E_bins):
            f.write('%i %10.10e resonance\n' %(i+j+1, mid_E_bins[j]))
    for k in range(num_low_E_bins+1):
        f.write('%i %10.10e thermal\n' %(i+j+k+2, low_E_bins[k]))
    f.close()

    # ---- variables updated in this function -----
    prob.low_E_bins = low_E_bins
    prob.mid_E_bins = mid_E_bins
    prob.high_E_bins = high_E_bins
    prob.group_file = group_file
    # ---------------------------------------------
    return prob
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
def read_group_struct(existing_group_file):
    existing_group_file = os.path.join(groupstructDirr, existing_group_file)
    (existing_1D, existing_2D) = ReadFile(existing_group_file)

    low_E_bins = []
    mid_E_bins = []
    high_E_bins = []
    for i in range(2,len(existing_2D)-1):
        if existing_2D[i][2] == 'thermal':     low_E_bins.append(np.float(existing_2D[i][1]))
        elif existing_2D[i][2] == 'resonance': mid_E_bins.append(np.float(existing_2D[i][1]))
        elif existing_2D[i][2] == 'fast':      high_E_bins.append(np.float(existing_2D[i][1]))

    # ---- variables updated in this function -----
    prob.low_E_bins = np.array(low_E_bins)
    prob.mid_E_bins = np.array(mid_E_bins)
    prob.high_E_bins = np.array(high_E_bins)

    prob.num_low_E_bins = len(low_E_bins)
    prob.num_mid_E_bins = len(mid_E_bins)
    prob.num_high_E_bins = len(high_E_bins)
    # ---------------------------------------------
    return prob
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
def create_PDT_xs(prob, geom):
    # ----- variables used in this function -------
    time_dependent = prob.time_dependent
    min_binwidth = prob.min_binwidth 
    log_spacing = prob.log_spacing
    num_low_E_bins = prob.num_low_E_bins
    num_mid_E_bins = prob.num_mid_E_bins
    num_high_E_bins = prob.num_high_E_bins
    mid_E_bins = prob.mid_E_bins
    num_elements_RRR = prob.num_elements_RRR
    group_file = prob.group_file
    scat_leg_order = prob.scat_leg_order 
    # ---------------------------------------------

    num_bins = num_low_E_bins + num_mid_E_bins + num_high_E_bins
    num_FEDS_groups = num_low_E_bins + num_elements_RRR + num_high_E_bins

    os.system('mkdir '+str(prob.dir))
    make_PDT_xs_file = str(prob.dir)+'/make_xs_'+str(num_bins)+'_'+str(num_elements_RRR)+'.sh'

    f3 = open(make_PDT_xs_file, 'w')

    f3.write("#! /usr/bin/env bash \n")
    f3.write("# Pablo Vaquer, Summer Internship 2018 \n\n")
    f3.write("############################ \n")
    f3.write("# INITIALIZE VARIABLES \n")
    f3.write("############################ \n\n")
    f3.write("## !!!!! \n")
    f3.write("# You need to set and export the following: \n")
    f3.write("# export SCRATCH_BARN=... \n")
    f3.write("# export ENDF=... \n")
    f3.write("# export NJOY=... \n")
    f3.write("## !!!!! \n\n")
    f3.write("# This is a resolution parameter used in indicators.py only. I usually just set it at 9.\n")
    f3.write("res=9 \n\n")
    f3.write("# This is the minimum bin width for a single sublement (use 1e-4 to avoid seg faulting in ERRORR)\n")

    f3.write("bin=%2.2e \n\n" %min_binwidth)

    f3.write("# In addition to coarse groups, I use energy penalties. \n")
    f3.write("# See my dissertation, Appendix B, section 1 for more details \n")

    if time_dependent == True:
        f3.write("penalty=-0.5 \n\n" )
    else:
        f3.write("penalty=0 \n\n" )

    f3.write("# Which problem to run, materials-wise. \n")
    f3.write("# This is only used in indicators.py and indicators_clustering.py, \n")
    f3.write("# where there is a mapping from this string to a set of materials defined in \n")
    f3.write("# materials_materials.py. \n")
    
    if len(geom.unimportantMats) > 0:
        f3.write("unimportantMatsExist=1 \n")
    else:
        f3.write("unimportantMatsExist=0 \n")
    
    f3.write("m="+geom.Name+" \n\n")
    f3.write("# The specific list of materials to generate NJOY inputs for / read NJOY outputs from  \n")
    f3.write("# This is only used in calls to materials.py \n")
    f3.write("mUNIMPORTANTlist=(")
    for unimportant_mat in geom.unimportantMats:
        f3.write(str(unimportant_mat.Name)+" ")
    f3.write(")  \n\n")

    f3.write("# We need PENDF files for all the materials to do the clustering, \n")
    f3.write("# but we can only do half of the materials at a time due to incompatible \n")
    f3.write("# thermal treatments  \n")
    f3.write("mIMPORTANTlist=(")
    for important_mat in geom.importantMats:
        f3.write(str(important_mat.Name)+" ")
    f3.write(")  \n\n")

    f3.write("# How many elements to use in the resolved resonance region (RRR). \n")
    f3.write("g=%i \n\n" %num_elements_RRR)

    if prob.element_type in ['feds','FEDS']:
        f3.write("# These are the coarse-group boundaries in eV. c also specifies the extent of the RRR \n")
        f3.write("c=(")
        mid_E_bins = mid_E_bins[::-1]
        for i in range(len(mid_E_bins)):
            f3.write('%10.10e ' %mid_E_bins[i])
        f3.write(") \n\n")

    f3.write("# The group structure to use outside the RRR in the thermal and fast energy ranges. \n")
    f3.write("# G=shem-361 would point to ../dat/energy_groups/shem-361.txt \n")

    if log_spacing == True:
        f3.write("G="+"log-"+str(num_low_E_bins)+"-"+str(num_mid_E_bins)+"-"+str(num_high_E_bins)+" \n")
    else:
        f3.write("G="+"lin-"+str(num_low_E_bins)+"-"+str(num_mid_E_bins)+"-"+str(num_high_E_bins)+" \n")  

    f3.write(" \n")
    f3.write("# How many Legendre moments to use for the scattering transfer matrices \n")

    f3.write("L="+str(scat_leg_order)+" \n\n")

    f3.write("# Which clustering algorithm to use. Recommended: use 'tmg' for MG XS and 'har' for FEDS XS \n")
    f3.write("# Use './indicators_clustering.py -h' for more information. \n")
    f3.write("clusterer=har \n\n")
    f3.write("# Which apportioning algorithm to use. Recommended: use 'var' for FEDS and 'L1' or 'max' for MG XS \n")
    f3.write("# Use './indicators_clustering.py -h' for more information. \n")

    f3.write("appt="+prob.apportion_algorithm+" \n")

    f3.write(" \n")
    f3.write("# Which reactions to include in the PDT XS file. Recommended: use 'abs' if absorption edits are needed \n")
    f3.write("# Use './materials.py -h' for more information \n")
    
    f3.write("rxnOpt="+prob.rxnOpt+" \n\n")

    f3.write("# Use './materials.py -h' for more information \n")
    f3.write("weightOpt=(2) \n")
    f3.write("#weightOpt=(4 .1265 .0253 .1265 1.4e6) \n")
    f3.write(" \n")

    f3.write("############################ \n")
    f3.write("# GENERATE CROSS SECTIONS \n")
    f3.write("############################ \n")
    f3.write(" \n")
    f3.write("#NB: In many cases, if a previous step has run successfully, you don't need \n")
    f3.write("# to rerun it to run a later step if you make changes that affect that later \n")
    f3.write("# step only. \n")
    f3.write("echo '                  (         )   (      (      (           ' \n")
    f3.write("echo '   (      (       )\ )   ( /(   )\ )   )\ )   )\ )        ' \n")
    f3.write("echo ' ( )\     )\     (()/(   )\()) (()/(  (()/(  (()/(   (    ' \n")
    f3.write("echo ' )((_) ((((_)(    /(_)) ((_)\   /(_))  /(_))  /(_))  )\   ' \n")
    f3.write("echo '((_)_   )\ _ )\  (_))    _((_) (_))_| (_))   (_))   ((_)  ' \n")
    f3.write("echo ' | _ )  (_)_\(_) | _ \  | \| | | |_   |_ _|  | _ \  | __| ' \n")
    f3.write("echo ' | _ \   / _ \   |   /  | .` | | __|   | |   |   /  | _|  ' \n")
    f3.write("echo ' |___/  /_/ \_\  |_|_\  |_|\_| |_|    |___|  |_|_\  |___| ' \n")
    f3.write("echo \n")
    f3.write("echo '------- Step 0: Initializing the scratch directory -------' \n")
    f3.write("scriptdir=`pwd` \n")
    f3.write("srcdir="+srcDict['src']+" \n")
    f3.write("cd $srcdir\n")
    f3.write("./Initialize.py $scriptdir $0 \n")
    f3.write(" \n")

    if prob.element_type in ['mg','MG']:
        f3.write("echo '------- Step 1: Generating the NJOY inputs -------' \n")
        f3.write("mList=${mIMPORTANTlist[*]} \n")
        f3.write("./materials.py -m ${mList[*]} -W ${weightOpt[*]} -G $G -v \n")
        f3.write(" \n")
        f3.write("echo '------- Step 2: Running NJOY to generate the PENDF file -------' \n")
        if prob.new_PENDF == False or prob.start_at_step > 2: f3.write("#")
        f3.write("cd $SCRATCH_BARN/xs \n")
        if prob.new_PENDF == False or prob.start_at_step > 2: f3.write("#")
        f3.write("./RunPendf.sh \n")
        f3.write("echo '------- Step 3: Running NJOY to generate GENDF files (on the subelements) -------'  \n")
        if prob.new_GENDF == False or prob.start_at_step > 3: f3.write("#")
        f3.write("cd $SCRATCH_BARN/xs \n")
        if prob.new_GENDF == False or prob.start_at_step > 3: f3.write("#")
        f3.write("./RunGendf.sh \n")
        #if prob.new_ACE == False: f3.write("#")
        #f3.write("./RunAce.sh \n")
        f3.write("echo '------- Step 4: Summing/averaging over the subelements to get PDT-formatted FEDS XS on the elements -------'  \n")
        f3.write("cd $srcdir \n")
        f3.write("./materials.py -b -m ${mList[*]} -p $rxnOpt -W ${weightOpt[*]} -v \n")
        f3.write(" \n")
        f3.write('if [ "${unimportantMatsExist}" = 1 ] \n')
        f3.write("then \n")
        f3.write("    echo '------- Step 1: Generating the NJOY inputs -------'  \n")
        f3.write("    mList=${mUNIMPORTANTlist[*]} \n")
        f3.write("    ./materials.py -m ${mList[*]} -W ${weightOpt[*]} -G $G -v  \n")
        f3.write("      \n")
        f3.write("    echo '------- Step 2: Running NJOY to generate the PENDF files -------'  \n")
        if prob.new_PENDF == False or prob.start_at_step > 2: f3.write("#")
        f3.write("    cd $SCRATCH_BARN/xs \n")
        if prob.new_PENDF == False or prob.start_at_step > 2: f3.write("#")
        f3.write("    ./RunPendf.sh  \n")
        f3.write("    echo '------- Step 3: Running NJOY to generate GENDF files (on the subelements) -------'  \n")
        if prob.new_GENDF == False or prob.start_at_step > 3: f3.write("#")
        f3.write("    cd $SCRATCH_BARN/xs \n")
        if prob.new_GENDF == False or prob.start_at_step > 3: f3.write("#")
        f3.write("    ./RunGendf.sh \n")
        #if prob.new_ACE == False: f3.write("#")
        #f3.write("    ./RunAce.sh \n")
        f3.write("    echo '------- Step 4: Summing/averaging over the subelements to get PDT-formatted FEDS XS on the elements -------'  \n")
        f3.write("    cd $srcdir \n")
        f3.write("    ./materials.py -b -m ${mList[*]} -p $rxnOpt -W ${weightOpt[*]} -v \n")
        f3.write("fi \n")


    elif prob.element_type in ['feds','FEDS']:
        f3.write("echo '------- Step 1: Generating the NJOY inputs -------' \n")
        f3.write("mList=${mIMPORTANTlist[*]} \n")
        f3.write("./materials.py -m ${mList[*]} -W ${weightOpt[*]} -v \n")
        f3.write(" \n")
        f3.write("echo '------- Step 2: Running NJOY to generate the PENDF file -------' \n")
        if prob.new_PENDF == False or prob.start_at_step > 2: f3.write("#")
        f3.write("cd $SCRATCH_BARN/xs \n")
        if prob.new_PENDF == False or prob.start_at_step > 2: f3.write("#")
        f3.write("./RunPendf.sh \n")
        if prob.new_PENDF == False or prob.start_at_step > 2: f3.write("#")
        f3.write("cd $srcdir \n")
        f3.write(" \n")

        f3.write('if [ "${unimportantMatsExist}" = 1 ] \n')
        f3.write("then \n")
        f3.write("    echo '------- Step 1: Generating the NJOY inputs -------'  \n")
        f3.write("    mList=${mUNIMPORTANTlist[*]} \n")
        f3.write("    ./materials.py -m ${mList[*]} -W ${weightOpt[*]} -v  \n")
        f3.write("      \n")
        f3.write("    echo '------- Step 2: Running NJOY to generate the PENDF files -------'  \n")
        if prob.new_PENDF == False or prob.start_at_step > 2: f3.write("#")
        f3.write("    cd $SCRATCH_BARN/xs \n")
        if prob.new_PENDF == False or prob.start_at_step > 2: f3.write("#")
        f3.write("    ./RunPendf.sh  \n")
        if prob.new_PENDF == False or prob.start_at_step > 2: f3.write("#")
        f3.write("    cd $srcdir  \n")
        f3.write("fi \n")

        f3.write(" \n")
        f3.write("echo '------- Step 3: Generating the indicators and their energy grid -------' \n")
        if prob.new_GENDF == False or prob.start_at_step > 3: f3.write("#")
        f3.write("./indicators.py -R ${c[0]} ${c[*]: -1} -m $m -w flux -r $res -G $G -v -Z -s $bin \n")
        f3.write(" \n")
        f3.write("echo '------- Step 4: Generating more indicators on the same energy grid but using escape XS -------' \n")
        if prob.new_GENDF == False or prob.start_at_step > 4: f3.write("#")
        f3.write("./indicators.py -R ${c[0]} ${c[*]: -1} -m $m -w sigt -r $res -G $G -v -Z -s $bin\n")
        f3.write(" \n")
        f3.write("echo '------- Step 5: Clustering the indicators to get the clust file, which specifies the energy mesh -------' \n")
        if prob.new_GENDF == False or prob.start_at_step > 5: f3.write("#")

        if prob.plot_fluxes == True:
            f3.write("./indicators_clustering.py -c ${c[*]} -e $g -m $m -w $clusterer -E $penalty -r $res -a $appt -v 3 -d 500 -S -p all  \n")
        else:
            f3.write("./indicators_clustering.py -c ${c[*]} -e $g -m $m -w $clusterer -E $penalty -r $res -a $appt -v 3 -d 500 -S -p none  \n")

        f3.write(" \n")
        f3.write("echo '------- Step 6: Generating the weighting spectrum on the subelements -------' \n")
        if prob.new_GENDF == False or prob.start_at_step > 6: f3.write("#")
        f3.write("./indicators.py -R ${c[0]} ${c[*]: -1} -m $m -w wgt -r $res -G $G -v -Z -s $bin -M clust-$g-$res \n")
        f3.write(" \n")

        f3.write("# Do for important materials: \n")
        f3.write("mList=${mIMPORTANTlist[*]} \n")

        f3.write("echo '------- Step 7: Regenerating NJOY inputs with a group structure of the subelements -------'  \n")
        if prob.new_GENDF == False or prob.start_at_step > 7: f3.write("#")
        f3.write("./materials.py -m ${mList[*]} -G clust-$g-$res -L $L -W ${weightOpt[*]} -v  \n")
        f3.write("echo '------- Step 8: Running NJOY to generate GENDF files (on the subelements) -------'  \n")
        if prob.new_GENDF == False or prob.start_at_step > 8: f3.write("#")
        f3.write("cd $SCRATCH_BARN/xs \n")
        if prob.new_GENDF == False or prob.start_at_step > 8: f3.write("#")
        f3.write("./RunGendf.sh \n")
        #if prob.new_ACE == False: f3.write("#")
        #f3.write("./RunAce.sh \n")
        f3.write("echo '------- Step 9: Summing/averaging over the subelements to get PDT-formatted FEDS XS on the elements -------'  \n")
        f3.write("cd $srcdir \n")
        #f3.write("./materials.py -b -m ${mList[*]} -p $rxnOpt -M clust-$g-$res -W ${weightOpt[*]} -v -x $MCNPflux  \n")
        if prob.new_GENDF == False or prob.start_at_step > 9: f3.write("#")
        f3.write("./materials.py -b -m ${mList[*]} -p $rxnOpt -M clust-$g-$res -W ${weightOpt[*]} -v \n")
        f3.write(" \n")
        f3.write('if [ "${unimportantMatsExist}" = 1 ] \n')
        f3.write("then \n")
        f3.write("    # Do for unimportant materials: \n")
        f3.write("    mList=${mUNIMPORTANTlist[*]} \n")
        f3.write("    echo '------- Step 7: Regenerating NJOY inputs with a group structure of the subelements -------'  \n")
        if prob.new_GENDF == False or prob.start_at_step > 7: f3.write("#")
        f3.write("    ./materials.py -m ${mList[*]} -G clust-$g-$res -L $L -W ${weightOpt[*]} -v  \n")
        f3.write("    echo '------- Step 8: Running NJOY to generate GENDF files (on the subelements) -------'  \n")
        if prob.new_GENDF == False or prob.start_at_step > 8: f3.write("#")
        f3.write("    cd $SCRATCH_BARN/xs \n")
        if prob.new_GENDF == False or prob.start_at_step > 8: f3.write("#")
        f3.write("    ./RunGendf.sh \n")
        #if prob.new_ACE == False: f3.write("#")
        #f3.write("    ./RunAce.sh \n")
        f3.write("    echo '------- Step 9: Summing/averaging over the subelements to get PDT-formatted FEDS XS on the elements -------'  \n")
        f3.write("    cd $srcdir \n")
        if prob.new_GENDF == False or prob.start_at_step > 9: f3.write("#")
        f3.write("    ./materials.py -b -m ${mList[*]} -p $rxnOpt -M clust-$g-$res -W ${weightOpt[*]} -v 2 \n")
        f3.write("fi \n")
    else:
        print "** Error: prob.element_type should be 'mg' or 'feds'"

    f3.write(" \n")
    f3.write("echo ' The result should be a list of .data files in $scratch/xs/pdtxs ' \n")
    f3.write(" \n")
    f3.write("####################### \n")
    f3.write("sleep 0.1 \n")

    f3.write(" \n")
    for mat in geom.unimportantMats:
        f3.write("cp $SCRATCH_BARN/xs/pdtxs/BarnfireXS_%s_%i.xml $scriptdir/%s/. \n" %(mat.Name, num_FEDS_groups, prob.dir) )
    for mat in geom.importantMats:
        f3.write("cp $SCRATCH_BARN/xs/pdtxs/BarnfireXS_%s_%i.xml $scriptdir/%s/. \n" %(mat.Name, num_FEDS_groups, prob.dir) )
    f3.write("cp $SCRATCH_BARN/dat/indicators/flux.xml $scriptdir/%s/flux_%ith_%icg_%iel_%iurr.xml \n" %(prob.dir, prob.num_low_E_bins, prob.num_mid_E_bins, prob.num_elements_RRR, prob.num_high_E_bins) )
    f3.write("cp $SCRATCH_BARN/dat/energy_groups/clust-$g-$res.xml $scriptdir/%s/clust_%ith_%icg_%iel_%iurr.xml\n" %(prob.dir, prob.num_low_E_bins, prob.num_mid_E_bins, prob.num_elements_RRR, prob.num_high_E_bins) )
    f3.write("#######################\n")

    f3.write("rm *.~ *.pyc\n")

    f3.close()

    # ---- variables updated in this function -----
    prob.make_PDT_xs_file = make_PDT_xs_file
    prob.num_bins = num_bins
    prob.num_FEDS_groups = num_FEDS_groups
    # ---------------------------------------------
    return prob
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
dirDict = directories.get_root_directories()
headDirr = dirDict['head']
srcDict = directories.get_source_directories(headDirr)
srcDirr = srcDict['src']
sys.path.append(srcDirr)
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
def find_append_to_file(filename, find, new_lines, option='after'):
    with open(filename, 'r+') as f:
        while len(f.readline()) > 0:
            line = f.readline()
            print line
            index = repr(line).find(find) - 1
            if index > -1: 
                print line
                f.write(new_lines)
    f.close()
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
class Element():
    def __init__(self):
        self = self
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
class Material_Geometry:
    def __init__(self):
        self = self
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
class Material():
    def __init__(self, Name=None, temperature=None, atomDensity=None, massDensity=None, chordLength=None, abundanceDict=None, elemAtomFracDict=None, elemMassFracDict=None, ZAList=None, ZList=None, symDict=None, backgroundXSDict=None, thermalOpt=0, elemWeightDict=None, matlWeight=None, SabDict=None, thermalXSDict=None, temperatureIndex=0):
        '''The following units are used:
        temperature in Kelvin is the temperature of the material
        temperatureIndex is the least-significant digit of an MCNP-like matl. name and refers to temperature
        atomDensity in atoms/barn-cm is the atom density of the material
        massDensity in g/cm^3 is the mass density of the material
        chordLength in cm is used to calculate the escape cross section; set to zero to use 0 escape XS
        abundanceDict is the atom fraction of each isotope in its element
        elemAtomFracDict is the atom fraction of each element in the material
        elemMassFracDict is the mass/weight fraction of each element in the material
        elemWeightDict is the elemental mass/weight in g/mole calculated using the correct abundances
        matlWeight in g/mole is the effective weight of the material
        ZAList is a list of all (Z,A) = (atomic number, atomic mass) pairs in the material
        ZList is a list of all elements in the material stored as atomic number
        symDict is the chemical symbol for each element in the material
        backgroundXSDict is an approximate background XS seen by each nuclide in the material
        thermalOpt specifies which thermal treatment to use
        SabDict is the thermal S(alpha,beta) Hollerith string used for each nuclide in the material
        thermalXSDict is a list of thermal XS used for each nuclide (list of shortName's in endfMTList)
        shortName is a succinct name without whitespaces
        longName is a longer name that may contain whitespace
        '''
        # locals() includes local names, including 'self'. Update Material to include all keywords above.
        varss = locals()
        self.__dict__.update(varss)
        del self.__dict__["self"]
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
def add_lines_to_file(file_name, search_string, new_lines, option='add', exception='get_unicornblood_material()'):
    f = open(file_name)
    for line in f:
        if exception in line:
            print '\n** Warning: "'+exception+'" was already found in "'+file_name+'"'
            option='none'
    f.close()

    if option == 'add':
        for i in range(len(new_lines)-1,-1,-1):
            print 'sed -i "/'+search_string+'/a'+new_lines[i]+'" '+file_name
            os.system('sed -i "/'+search_string+'/a'+new_lines[i]+'" '+file_name)

    elif option == 'replace':
        print 'sed -i s/"'+search_string+'"/"'+new_lines+'"/g '+file_name
        os.system('sed -i s/"'+search_string+'"/"'+new_lines+'"/g '+file_name)
        #for i in range(len(new_lines)-1,-1,-1):
        #    print 'sed -i "/'+search_string+'/a'+new_lines[i]+'" '+file_name
        #    os.system('sed -i "/'+search_string+'/a'+new_lines[i]+'" '+file_name)

    else:
        print '** Warning: Material not added to "'+file_name+'"'
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
def modify_materials_materials_source_code(geom):
    for mat in geom.importantMats + geom.unimportantMats:
        print mat.Name
        new_lines = []
        new_lines.append("\        '%s': get_%s_material," %(mat.Name, mat.Name))

        search_string = '# Call Generated By Python Script'
        add_lines_to_file(os.path.join(srcDirr,'materials_materials.py'), search_string, new_lines, exception='get_'+mat.Name+'_material,')

        new_lines = []
        new_lines.append("def get_%s_material(): " %mat.Name)
        new_lines.append("\    # %s" %datetime.datetime.now())
        new_lines.append("\    shortName = '%s' " %mat.Name)
        new_lines.append("\    longName = '%s' " %mat.Name)
        new_lines.append("\    massDensity = %.4f #g/cc " %mat.massDensity)
        new_lines.append("\    fuelRadius = %.4f #cm " %mat.fuelRadius)
        new_lines.append("\    temperature = %.1f #K " %mat.temperature)
        new_lines.append("\    thermalOpt = 'none' ")
        for i in range( len(mat.elements) ): 
            new_lines.append("\    %sAtomFractionsDict = %s " %(mat.elements[i].name, mat.elements[i].AtomFractionsDict) )
        new_lines.append("\    elemAtomFracDict = %s" %mat.elemAtomFracDict)
        new_lines.append("\    # ")
        if mat.fuelRadius < 1e-14 or mat.shape not in ['sphere', 'cyl', 'cube']:
            new_lines.append("\    chordLength = 0")
        else:
            new_lines.append("\    chordLength = calc_chord_length('"+str(mat.shape)+"', fuelRadius)")
        new_lines.append("\    symDict, ZList, ZAList = get_all_isotopes(elemAtomFracDict) ")
        new_lines.append("\    abundanceDict = lookup_natl_abundances(ZAList) ")
        for i in range( len(mat.elements) ): 
            new_lines.append("\    override_abundances(ZAList, abundanceDict, %sAtomFractionsDict, '%s') " %(mat.elements[i].name, mat.elements[i].Name))
        new_lines.append("\    # ")
        new_lines.append("\    material = Material( ")
        new_lines.append("\        shortName=shortName, longName=longName, ")
        new_lines.append("\        temperature=temperature, thermalOpt=thermalOpt, ")
        new_lines.append("\        symDict=symDict, ZList=ZList, ZAList=ZAList, ")
        new_lines.append("\        abundanceDict=abundanceDict, chordLength=chordLength, ")
        new_lines.append("\        elemAtomFracDict=elemAtomFracDict, massDensity=massDensity) ")
        new_lines.append("\    return material ")
        new_lines.append("\ ")

        search_string = '# Function Generated By Python Script'

        add_lines_to_file(os.path.join(srcDirr,'materials_materials.py'), search_string, new_lines, exception='get_'+mat.Name+'_material()')
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
def modify_indicators_source_code(geom):
    #for mat in geom.importantMats + geom.unimportantMats:
    #    search_string = "'godiva',"
    #    new_lines =  "'godiva','"+mat.Name+"',"
    #    add_lines_to_file(os.path.join(srcDirr,'indicators.py'), search_string, new_lines, option='replace', exception="'"+mat.Name+"',")

    search_string = "'3',"
    new_lines =  "'"+geom.Name+"','3',"
    add_lines_to_file(os.path.join(srcDirr,'indicators.py'), search_string, new_lines, option='replace', exception="'"+geom.Name+"',")

    search_string = '# Materials generated by python script'
    new_lines = []
    new_lines.append("\    elif materialOpt == '%s':" %geom.Name)
    for mat in geom.importantMats:
        new_lines.append("\        materials.append(mat.get_%s_material())" %mat.Name)
    if len(geom.unimportantMats) > 0:
        new_lines.append("\        if workOpt == 'wgt':")
    for mat in geom.unimportantMats:
        new_lines.append("\            materials.append(mat.get_%s_material())" %mat.Name)
        print search_string, new_lines
        #add_lines_to_file(os.path.join(srcDirr,'indicators.py'), search_string, new_lines, option='replace', exception="'"+mat.Name+"',")
    add_lines_to_file(os.path.join(srcDirr,'indicators.py'), search_string, new_lines, exception="materialOpt == '"+geom.Name+"'")
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
def modify_indicators_clustering_source_code(geom):
    #for mat in geom.importantMats + geom.unimportantMats:
    #    print mat.Name
    #    search_string = "'godiva',"
    #    new_lines =  "'godiva','"+mat.Name+"',"
    #    add_lines_to_file(os.path.join(srcDirr,'indicators_clustering.py'), search_string, new_lines, option='replace', exception="'"+mat.Name+"',")
    search_string = "'4',"
    new_lines =  "'"+geom.Name+"','4',"
    add_lines_to_file(os.path.join(srcDirr,'indicators_clustering.py'), search_string, new_lines, option='replace', exception="'"+geom.Name+"',")

    search_string = '# Materials generated by python script'
    new_lines = []
    new_lines.append("\    elif materialOpt == '%s':" %geom.Name)
    new_lines.append("\        importanceDict = %s " %geom.importanceDict)
    add_lines_to_file(os.path.join(srcDirr,'indicators_clustering.py'), search_string, new_lines, exception="materialOpt == '"+geom.Name+"'")
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
class problem:
    def __init__(self):
        self = self
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%





